# Docker Compose Nodejs and MongoDB template

## Why this project?
This is a sample project showcasing basic design and templating for a MEAN/MERN stack application this isn't proprietary. 
Mongo is a quick and easy document DB that is very popular. 
Node is one of the most popular JS web servers.
Express is one of the most popular web frameworks for Node.
And Mongoose is a straightforward promise-based ODM useful for small scale apps like this one.


## Start the sample project
Starting is as easy as one cammand (with docker engine & 
docker-compose installed on your system)
```bash
docker compose up -d
```

## Stop the sample project
Also a single command to remove all containers, but leave images, volumes, and networks in place:
```bash
docker compose down
```

To stop and remove all containers, networks, and all images used by any service in <em>docker-compose.yml</em> file, use the command:
```bash
docker compose down --rmi all
```
Note that this method removes the mongoDB data; be sure to use a separate volume if you intent to persist that data after an --rmi flag.

## Modifying and maintaining the project:
### Add new packages
First include all new packages in <em>package.json</em>:
```json
{
  ...
  "dependencies": {
    "packagename": "^1.0.0",
    ...
  }
}
```
and then you can import into server.js:
```js
require("packagename").exportname();
```

### Change business logic in the Controllers
Controllers are in the app/controllers/ directory
Presently, they are implemented using the CRUD promises
generated by Mongoose (see Modify Database Document Models
for more information), but you can change or make your own here.

Don't forget to create a router for your business logic APIs 
in /app/routes, and requiring it in the export in /routes/index.js.

#### Pagination
Certain controllers may return a lot of information at once. You
can manage the returned results for a number of webpage improvements
by using server-side pagination. 

This simple example will not return data in pages, but turn to other
examples in branches if that is a requirement for your project or 
understanding.

### Access API through routers
Routes can be found in the app/routes/ directory

While controllers dictate what logic can be done, the routers
allow that logic to be accessed in the API. Each model should 
have its own controller and its own router.

routers should define the base path for this section of the
api, and the suffix path. Try to reuse the same suffix path 
for related POST/PUT/GET/DELETE commands, rather than making
a unique path for different functions on the same objects.

Once you create a router file (newroute.routes.js), you should 
include it in your routes index.js for import by server.js.

```js
module.exports = app => {
    require("./sample.routes")(app);
    require("./newroute.routes")(app);
};
```

This allows the app to import and use your new route on startup.



### Modify Database document models
Mongoose is used to represent the format for object documents
in mongoDB for us in order to keep sanity for programatically 
added data.

In a model such as the sample schema:
```js
module.exports = mongoose => {
  const Sample = mongoose.model(
    "sample",
    mongoose.Schema(
      {
        title: String,
        description: String,
        optionalProp: Boolean
      },
      { timestamps: true }
    )
  );

  return Sample;
};
```
the mongoose object, Sample, represents the Sample "Collection"
in the mongo DB. IN addtion to the three chosen properties, 
Mongoose will automatically add createdAt & updatedAt timestamps
(thanks to our timestamps option added above), a unique _id field,
and __v.

If this project is used as a template for a front-end which 
requires an "id" field instead of "_id", then you can override the
toJSON method like so:

```js
module.exports = mongoose => {
  var schema = mongoose.Schema(
    {
      title: String,
      description: String,
      optionalProp: Boolean
    },
    { timestamps: true }
  );

  schema.method("toJSON", function() {
    const { __v, _id, ...object } = this.toObject();
    object.id = _id;
    return object;
  });

  const Sample = mongoose.model("sample", schema);
  return Sample;
};
```

Mongoose creates our CRUD functions for us:
- Create: object.save()
- Retrieve/find by id: findById(id)
- Retrieve/find all objects by field-search: find({ fieldname: { $regex: new - RegExp(fieldname), $options: “i” } })
- Retrieve/find all objects: find()
- Update an object by id: findByIdAndUpdate(id, data)
- Delete/Remove an object by id: findByIdAndRemove(id)
- Delete/Remove all objects: deleteMany()