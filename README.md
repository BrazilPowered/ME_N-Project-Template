# Docker Compose Nodejs and MongoDB template

## Why this project?
This is a sample project showcasing basic design and templating for a MEAN/MERN stack application this isn't proprietary. 
Mongo is a quick and easy document DB that is very popular. 
Node is one of the most popular JS web servers.
Express is one of the most popular web frameworks for Node.
And Mongoose is a straightforward promise-based ODM useful for small scale apps like this one.

Note, some code may differe slightly from this guide, as small edits are made for compactness or clarity when posted in this doc.


## Start the sample project
Starting is as easy as one cammand (with docker engine & 
docker-compose installed on your system)
```bash
docker compose up -d
```

## Stop the sample project
Also a single command to remove all containers, but leave images, volumes, and networks in place:
```bash
docker compose down
```

To stop and remove all containers, networks, and all images used by any service in <em>docker-compose.yml</em> file, use the command:
```bash
docker compose down --rmi all
```
Note that this method removes the mongoDB data; be sure to use a separate volume if you intent to persist that data after an --rmi flag.

## Modifying and maintaining the project:
### Add new packages
First include all new packages in <em>package.json</em>:
```json
{
  ...
  "dependencies": {
    "packagename": "^1.0.0",
    ...
  }
}
```
and then you can import into server.js:
```js
require("packagename").exportname();
```

### Change business logic in the Controllers
Controllers are in the app/controllers/ directory
Presently, they are implemented using the CRUD promises
generated by Mongoose (see Modify Database Document Models
for more information), but you can change or make your own here.

Don't forget to create a router for your business logic APIs 
in /app/routes, and requiring it in the export in /routes/index.js.

#### Pagination
Certain controllers may return a lot of information at once. You
can manage the returned results for a number of webpage improvements
by using server-side pagination. 

This example doesn't use pagination, favoring to focus on Authentication
and Authorization, but pagination of simple data andf paginated data
woudl work altogether the same.

### Access API through routers
Routes can be found in the app/routes/ directory

While controllers dictate what logic can be done, the routers
allow that logic to be accessed in the API. Each model should 
have its own controller and its own router.

routers should define the base path for this section of the
api, and the suffix path. Try to reuse the same suffix path 
for related POST/PUT/GET/DELETE commands, rather than making
a unique path for different functions on the same objects.

Once you create a router file (newroute.routes.js), you should 
include it in your routes index.js for import by server.js.

```js
module.exports = app => {
    require("./sample.routes")(app);
    require("./newroute.routes")(app);
};
```

This allows the app to import and use your new route on startup.



### Modify Database document models
Mongoose is used to represent the format for object documents
in mongoDB for us in order to keep sanity for programatically 
added data.

In a model such as the sample schema:
```js
module.exports = mongoose => {
  const Sample = mongoose.model(
    "sample",
    mongoose.Schema(
      {
        title: String,
        description: String,
        optionalProp: Boolean
      },
      { timestamps: true }
    )
  );

  return Sample;
};
```
the mongoose object, Sample, represents the Sample "Collection"
in the mongo DB. IN addtion to the three chosen properties, 
Mongoose will automatically add createdAt & updatedAt timestamps
(thanks to our timestamps option added above), a unique _id field,
and __v.

If this project is used as a template for a front-end which 
requires an "id" field instead of "_id", then you can override the
toJSON method like so:

```js
module.exports = mongoose => {
  var schema = mongoose.Schema(
    {
      title: String,
      description: String,
      optionalProp: Boolean
    },
    { timestamps: true }
  );

  schema.method("toJSON", function() {
    const { __v, _id, ...object } = this.toObject();
    object.id = _id;
    return object;
  });

  const Sample = mongoose.model("sample", schema);
  return Sample;
};
```

Mongoose creates our CRUD functions for us:
- Create: object.save()
- Retrieve/find by id: findById(id)
- Retrieve/find all objects by field-search: find({ fieldname: { $regex: new - RegExp(fieldname), $options: “i” } })
- Retrieve/find all objects: find()
- Update an object by id: findByIdAndUpdate(id, data)
- Delete/Remove an object by id: findByIdAndRemove(id)
- Delete/Remove all objects: deleteMany()



## Security Auth and RBAC with JWT
Using Token based authentication allows us to future proof this design
by allowing the authentication we are creating to work well with native
iOS/android mobile apps which cannot use sessions in the same way 
webapps alone do; at least not easily. Instead of returning a sessionID,
this will return a JWT which can be stored locally (web browser) in the
iOS keychain, or Android SharedPreferences when the time comes.

RBAC (Role Based Access Control) also allows us to manage large groups of users as easily as small groups of individuals by applying access controls to a small number of specific "roles," which can then be assigned to user profiles which inherit those roles' access abilities.

For an overview of how JWT works in greater detail 
and how it was implemented in this code, please 
look to the *Appendix* section at the bottom for 
"A Detailed Overview of JWT"


### Implementation of JWT Authentication and Authorization
We need to modify our architecture to add a few layers to the application.
Presently:

##### Previous Architecture:
1. HTTP Requests come in
2. They are picked up a valid router in node
3. They are validated by the CORS Middleware
  - They are then rejected by CORS && a response saying so is sent, OR
4. The request is sent to the routed controllers which can access our DB and perform business logic.

Our new architecture will inject an Authentication layer (JWT) and an 
Authorization Layer (we'll make here) to validate what any individual
authenticated user is allowed to do via *roles*.
 
##### New Architecture:
1. HTTP Requests come in
2. They are picked up a valid router in node
3. They are validated by the CORS Middleware
    - They are then rejected by CORS && a response saying so is sent, OR
    - CORS sees this as a valid request and:
4. The JWT Middleware verifies the JWT "Access Token"
    - The JWT "Access Token" is invalid, and a 403 HTTP response is sent (ending this flow), OR:
    - The JWT "Access Token" is valid, but expired, then:
      - a "Refresh Token" is sent; The JWT Middleware verifies the JWT "Refresh Token," and
          - The "Refresh Token" is invalid or Expired, and a 403 HTTP response is sent (ending this flow), OR
          - The "Refresh Token" is valid, and a new Access/Refresh Token pair is sent back; the flow continues to step 5 using the new JWT Access Token
    - OR the JWT "Access Token: was valid, and this proceeds to step 5
5. The Authorizatio Middleware now processes this JWT user's roles
    - The user does not have any of the roles stored in the Mongo auth DB records, OR
    - The user DOES have an appropriate role so:
6. The request is sent to the routed controllers which can access our DB and perform business logic.

Note that the Authorization middleware layer DOES have a DB connection,
but only for validating users and their level of access. The connection 
and "user" written for it to access the DB should be designed thusly.

##### Implementation package choices
We're going to use jsonwebtoken and bcryptjs for the authentication and 
hashing. The package "jsonwebtoken" is a simple package for JWTs, and bcryptjs is a fast javascript-only implementation of bcrypt. 
(One concern to note: bcrypt only uses the first 72bytes of data when 
matching passwords -- everything after that is ignored. 72 is still very 
strong, but something to think about in the future.)

We will also use the native crypto package to generate effective 
UUIDs for us via crypto.randomUUID()



#### Models Implementation
The first new code we need to implement for this architecture are the 
RBAC models for our DB. We will add them to *models/role.model.js*.
We will also add a "roles" object inside a new User model schema to 
incorporate these authentication changes going forward.
After, we'll add a separate model for the Refresh Tokens that we'll need to track in our DB.

role.model:
```js
module.exports = mongoose => {
  var schema = mongoose.Schema(
    {
      name: String
    }
  );

  const Role = mongoose.model("role", schema);
  return Role;
};
```

user.model:
```js
...
  var schema = mongoose.Schema(
    {
      name: String,
      email: String,
      password: String,
      phone: String,
      //this the new role object:
      roles: [
        {
          type: mongoose.Schema.Types.ObjectId,
          ref: "Role"
        }
      ]
    },
    { timestamps: true }
  );
...
```
These mongoose models will represent the Roles and Users collection as *Normalized* documents in our MongoDB.
This Users schema will allow an array of Roles objects to be stored with this user, with one or many Roles IDs associated for our Authentication Middleware to refer to (or reference). Associating the roles as separate IDs (rather than denormalizing them and embedding authrization directly in each user record) allows us to keep the data Normalized, or separated into their uniquely managed areas without affecting the referencing documents. We can change roles without updating every user, and visa-versa.

For the Refresh Tokens, we'll need to create some static methods on the
schema to autogenerate an appropriate timestamp and verify the validity
based upon it.

refreshToken.model:
```js
...
var schema = new mongoose.Schema({
    token: String,
    user: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "User",
    },
    expiration: { 
        type: Date, 
        index: {expireAfterSeconds: 0}//Mongo now Auto-removes this token when 'expiration' is < current time in seconds
    }
});
schema.statics.createToken = async function (user) {
    let expiration = new Date();
    expiration.setSeconds(
        expiration.getSeconds() + authConfig.jwtRefreshExpiration
    );
    let _token = crypto.randomUUID();
    let _object = new this({
        token: _token,
        user: user._id,
        expiration: expiration.getTime(),
    });
    let refreshToken = await _object.save();
    return refreshToken.token;
};
schema.methods.stillValid = function stillValid() {
    return valid = this.expiration.getTime() >= new Date().getTime();
}//Note: this is handled by the "expireAfterSeconds" index option, but there may be time between index auto-removal and expiration time

...
```

Note the index set up on "exipration." The option "expireAfterSeconds"
allows mongoDB to periodically remove these tokens when the expiration 
time passes. This might not happen at the immediate time of expiration, 
so any check of a refreshToken document can't rely solely on a token's 
existence to verify validity; the actual expiration must be verified, 
too. 

Next, it's important to note the two functions included in this model.
Mongoose "statics" functions are used to operate on the document object's
class and DB collection, as opposed to "methods" functions which require 
an object to be instatiated and operated on independently. Since we're 
creating a token, it makes sense to use a *statics* function to add this
new document to the collection, to be operated on later. Conversely, 
while checking an individual token's expiration is *stillValid* (eg. 
acting on a refreshToken Object), we would use Mongoose *methods*, as 
shown here.

The createToken *statics* function uses the crypto library to create a 
random unique token from a random UUID and save it as an object in our 
mongoDB. The verifyExpiration method returns a comparison of the 
expiration in the Refresh Token with the current Date-Time for 
validation.

The stillValid *methods* function verifies expiration on the token. as 
a *methods* function, it stands out that this expects to compare the
actual expiration of a single token, and therfore will only function
on an existing instantiated refreshToken object.


Never forget to import these in your server, or into the model index.


#### Middleware
The middleware is used to handle things like validation and logic 
specific to making Authentication and Authorization work well, but
not the core logic. We're going to write two pieces which validate 
our JWT, and makes sure the JWT is/isn't an elevated user (admin or 
moderator), and also to validate user signup to avoid duplicate
users and incorrect user roles.
We also add a separate Error checking function to capture any token
expired errors -- this will be used to kick off our Refresh Token
workflow.

Check the middleware/validateSignup.js and middleware/jwtAuth.js for
examples.

#### Controllers
We need to dictate how to control 
- Authentication: How to know who this user is
- Authorization: RBAC, or What to let this user do.

##### Authenticate Controller
We need to allow users to sign up, so we learn who they are,
and to sign in, so we know who they are among returning users.

Our Sign up process will be a part of the user controller & have to:
- modify the example user controller to include a default role when not specified

Our Sign-in controller will be part of a new auth controller & have to:
- verify the username exists in the DB
- verify the supplied password matches the stored password
- generate an appropriate JWT
- Return useful user info and the access token (JWT).

We'll start with a user controller. We'll ensure the code incorporates
our new roles, and the "user" default role we require.

```js
...
//See the controllers/user.controller for the complete controller.
user.save(user)
  .then(user => {
  //Add Roles for the new user
  if(req.body.roles){
    Role.find(
    {
      name: { $in: req.body.roles }
    })
    .then((roles)=>{
      user.roles = roles.map(role=>role._id);
      user.save().then(()=>{
        res.send({ message: "User was created Successfully!" });
      })
    })
  } else { //default case - set role to default role "user"
    Role.findOne({ name: defaultRole })
    .then((role)=>{
      user.roles= [role._id];
      user.save()
      .then(()=>{
        res.send({ message: "User was created successfully!"});
      })
    })
  }
  })
...
```

And we'll need to add a new login/signin function as an auth controller:
```js
User.findOne({ username: req.body.username })
  //fetch all "roles", too; exclude "__v" tag
  .populate("roles","-__v") 
...
  .then((user) => {//check password
    var passwordIsRight = bcrypt.compareSync(
      req.body.password, user.password
    );
    if (!passwordIsRight){
      return res.status(401).send({ accessToken: null,
                                    message: "Invalid Password" });
    }
    return user;
  })//create token & respond to client
  .then(async (user) => {
    RefreshToken.createToken(user)
    .then(({refreshToken,user}) => { //create JWT
      /*******Roles assigned to user******/
      var assignedRoles = [];
      ///** 
      user.roles.forEach(role => {
        assignedRoles.push(role.name.toUpperCase() + "_ROLE");
      });/*************************************/
      res.status(200).send({
        id:       user._id,
        username: user.username,
        email:    user.email,
        roles:    assignedRoles,
        accessToken: createAccessToken(user.id),
        refreshToken: refreshToken
      });
    });
  })
```

As seen above, the refresh token is added to the authentication response
so that clients ccan validate their sessions on the same device without 
logging in too often. Now we need a controller to handle that token 
refresh:

```js
RefreshToken.findOne({ token: userToken })
    .then((refreshToken)=>{
        //If yes, Check expiration.
        if(!RefreshToken.stillValid(refreshToken)){
          //If not valid, send response "EXPIRED"
          return res.status(403).json ({ message: "Refresh Token is expired; please sign in again manually."})
        }
        else{ //Call or create new token
          const newAccessToken = createAccessToken(refreshToken.user._id);
          return res.status(200).json({accessToken: newAccessToken,
                                       refreshToken: refreshToken.token})
        }
    })
```
Note how we resend the same refresh token while it's still valid.
Refresh tokens set a limit on how long a user can refresh their 
session without needing to enter a username and password. The 
tokens are setup to autoremove by mongoDB when they expire via 
the model.

##### Routes
In order to use the earlier validations while using the new 
signup & signin controllers, we now need to modify the routes 
accordingly:
```js
...
const {validateSignup} = require("../middleware/validateSignup.js")

//Just for this route, we need special headers for the JWT
app.use(function(req, res, next) {
  res.header(
    "Access-Control-Allow-Headers",
    "x-access-token, Origin, Content-Type, Accept"
  );
  next();
});
// Create a new User; validate their info & requested roles with middleware
router.post("/signup",
            [validateSignup.checkDuplicateUsers
             validateSignup.validateUserRoles], 
             user.create);
```

Then signing in and efreshing sessions with refresh tokens 
needs routhing, too:
```js
module.exports = app => {
    var router = require("express").Router();
    const authenticate = require("../controllers/authenticate.controller.js");

    //Just for this route, we need special headers for the JWT
    app.use(function(req, res, next) {
      res.header(
        "Access-Control-Allow-Headers",
        "x-access-token, Origin, Content-Type, Accept"
      );
      next();
    });

    //Authenticate a user
    router.post("/login", authenticate.login);

    //Refresh an access token with a refreshToken
    router.post("/refreshToken", authenticate.refreshToken);
  
    app.use("/authenticate", router);
}
```

### Using this code
Note that to use this api, roles should always be included in 
an array of literals (["role1","role2",etc]), and parameters
are included by express as req.query.\<paramname\> since 
req.params.\<paramname\> is used for Express to manage 
dynamic routes in an Express router (eg.: /api/user/***:id***)
instead.

#### From users' perspective
The frontend client then needs to be written to manage those 
tokens accordingly, but the backend is done.
One example is a "Stay Logged In" opt-in option, at which point
the client will kick off the refresh token process whenever it
receives the 401 "Expired" message.












---
# Appendix

## Detailed Overview of JWT
A JSon Web Token is comprised of 3 sections, all base64Url encoded, 
then separated by dots: an info `Header`, a data `Payload`, and a signed or encrypted `Signature`.
`HEADER.PAYLOAD.SIGNATURE`


#### Header
```json
{
  "typ": "JWT",
  "alg": "HS256"
}
```
Headers are almost always just these two required parts:
- `typ` is the type of token, JWT for this project
- `alg` is the Hashing Algorithm for generating the Signature token.
We are using HMAC-SHA256 to use a Secret Key, or HS256 for short. In future
projects, it will be worth using RSA and Public/Private key encryption instead.

#### Payload
```json
{
  //custom fields
  "sub": "123456fedcba",
  "username": "sampleuser",
  "email": "example@sample.com",
  "admin": "true",
  //standard fields
  "iss": "Example, author of Sample Site",
  "iat": 1637500704,
  "exp": 1637500740
}
```
The payload stores the relevant info we deem necessary for 
authentication in the form of "Claims," which are statements 
about the entity requesting the JWT. These claims can include 
username, id, and other identifying information.

##### Standard Payload Fields
In addition to these custom fields, there are a few built-in
pre-defined "Registered Claims" that we need to use. They are 
not mandatory, but are highly recommended (hence the pre-defined
nature):
- `iss` is the issuer of the JWT -- us.
- `iat` is the time the JWT was Issued AT.
- `exp` is the EXPiration time for this token.
Note these are all 3-chars long, as JWT is intended to be compact.

There are also Public Claims, which may overlap with fileds you want
to use, such as name, email, and sub (or user identifier) -- you should match these with 
the Claim names in the JWT Standard. All other claims are called 
"Private" claims, and will be defined by you in your own implementation.
More information on existing Public & Registered fields can be found here: 
https://www.iana.org/assignments/jwt/jwt.xhtml

##### Custom Payload Fields
It is important to note that JWT claim names should be kept short,
but more important that they are identifiable by your application.

Note that any information you provide in signed tokens is entirely 
readable by anyone, essentially plaintext. Do not include secret 
information like PII or passwords unless it is intended to be 
Publicly known. 

In our example, we included the user's name, email, and userid, but note
how we used "sub," one of the Public Claims outlined in the JWT definition
rather than a longer custom field like "userid."
Also note that we did not use their full name, password, or other 
non-public information. 
We also included a custom "admin" flag. Note that the client could 
alter this flag, now that they see it, which is why we will discuss 
validating your JWTs later (to avoid tampering).

#### Signature
The JWT signature requires the base64Url encoded header, encoded 
Payload, and a "secret" to all be signed by the algorithm defined 
*in* your header. This, altogether, is your JWT Signature.

```bash
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```
The signature is used to verify the message wasn't changed along the way, and, in the case of tokens signed with a private key, it can also verify that the sender of the JWT is who it says it is.

#### The Final Form: Putting all parts of the JWT together
The output is three base64Url strings which we'll separate by dots:

```
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.
eyJzdWIiOiIxMjM0NTZmZWRjYmEiLCJ1c2VybmFtZSI6InNhbXBsZXVzZXIiLCJlbWFpbCI6ImV4YW1wbGVAc2FtcGxlLmNvbSIsImFkbWluIjoidHJ1ZSIsImlzcyI6IkV4YW1wbGUsIGF1dGhvciBvZiBTYW1wbGUgU2l0ZSIsImlhdCI6MTYzNzUwMDcwNCwiZXhwIjoxNjM3NTAwNzQwfQ.
mfUNVktcFx6tiMyZBy6qYMAjMJjMgLswkiSL5oq4g8w
```
Note this is the real JWT for our example, and uses an "example" secret.
You can test JWT creating out and test debugging here:
https://jwt.io/#debugger-io